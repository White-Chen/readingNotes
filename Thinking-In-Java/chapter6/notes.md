###Chapter 6 : Access Control
####1. _包内访问权限/Package_
+ 通过关键字 **package** 将同一命名空间内的编译单元组合形成类库. 
+ **package** 应该在非注释行的第一行声明, 也就是说应该在import语句, 类定义语句之前. 
+ **package** 规范一般为逆序的域名, 这样可以保证包名的可扩展性以及唯一性. 
+ 如果一个类不显式声明其包名, 那么他具有默认的隐式包名: 项目中的源代码目录结构. 
+ 推荐项目中的源码目录结构与包名相对应, 因为这样可以避免隐式包名与显式包名不对应的问题, 且提高项目的可维护性. 
+ **package** 在JAVA解释器中的处理过程: 
    + 获取系统环境变量中的 **CLASSPATH** 地址. 一般包含多个地址, 作为搜索.class文件的根目录. 
    + 将包名中的.替换为地址分割符, 获取一个相对路径. 
    + 将以上两步获得的地址进行组合, 可以获得一组绝对路径. 
    + 对这组地址进行递归的查找, 直到找到相对应的.class文件, 并进行加载. 
    + 当然也许在JAVA解释器中的一些标准文件夹中进行查找, 在后期JDK版本中, 改机制有了进一步改进(书中没有明确写, 是指说了并不需要配置 **CLASSPATH**). 
+ 需要注意的是, **CLASSPATH** 一般配置的是类库所在的文件夹绝对路径. 但是有一个特例, 如果需要配置.jar文件, 则需要完整的声明该.jar文件所在的绝对路径, 而不是.jar文件所在目录的绝对路径. :heavy_exclamation_mark:
+ .jar文件全程是(JAVA Archive)文件, 是一种JAVA文件格式, 类似一种压缩包, 但是并不完全相同. 
    
####2. _import_
+ 类冲突时, 在调用冲突类是需要显式补全包名. 

####3. _JAVA访问权限符_
+ 不显式声明权限时, 隐式默认权限是包权限, 或者说friendly. 
+ 在一个类中获取另一个类的成员的几种方法: 
    + 将改成员的访问权限声明为 **public**. 
    + 将两个类放在同一个 **package**. 
    + 将成员声明为 **protected**, 然后通过继承关系进行访问. 
    + 通过提供对外开放的 **setter()/getter()** 方法进行操作, 这种方法在OOP中比较推崇的. 
    + 反射机制？书里到这还没有写到, 但是反射应该是可以用于攻击所谓的权限控制. :heavy_exclamation_mark:
+ **protected** 提供了一种包+继承类的访问权限. 
+ 在使用默认权限时, 存在一个问题, 就是继承类如果不在同一个包名下那么也无法获取父类的默认访问权限修饰的成员, 此时 **protected** 就起到了作用. 

####4. _类访问权限_
+ 一个编译单元, 也就是说一个.java文件中只能有一个 **public** 类. 
+ 如果一个编译单元中没有显示声明为 **public** 的类那么, 文件中类名可以任意命名而不用必须和文件名相同. 
+ 可以用 **private** 和 **protected** 修饰类访问权限, 这种情况一般出现在内部类中, 书的后续章节会进行详细说明. 
+ **private** 可以修饰构造方法, 这样可以避免其他类直接通过构造方法获取当前类的实例, 而在这样的情况下返回类实例的两种方法如下:
    + 通过单例模式进行实现, 单例模式在上一章节笔记已经说明, 该模式可以控制实例的唯一性. 
    + 提供一个静态公共方法用于返回类实例, 该方法用于统计类实例的数量, 从而对类的规模进行控制.  
    ```java
    public class PrivateClass{
      private PrivateClass(){}; 
      public static PrivateClass getInstance(){
          /*do something*/
          return new PrivateClass();
      }
    }
    ```