###Chapter 12 : Error Handling with Exception
**Java的基本理念就是结构不佳的代码不能运行**

####1. _概念_
+ 背景：C以及早期语言常常具有多种错误处理模式。这些模式中通常通过返回某个特殊值或者设置摸个标志，并且假定接收者将对这个返回值或标志进行检查。以判定是否发生错误。[这种方法有两个主要缺陷：1,每次调用方法时都需要进行彻底错误检查，这会产生大量冗余代码；另一点调用者完全可以不检查异常，这将导致程序健壮性收到极大影响.]()
+ 解决：用强制规定的形式消除错误处理过程中随心所欲的因素。。
+ 使用异常带来两点好处：1.总能有合适的地方处理或抛出异常，这使得你不得不正视异常处理，提高程序的健壮性；2.不需要在方法调用出进行异常检查，因为异常机制能够保证捕获异常，并只需要在一个合适的地方处理异常，这极大地降低了错误处理代码的复杂度。

####2. _基本异常_
+ 区别异常情形和普通问题情形：
    + 普通问题情形是指在 **当前环境** 下总能处理的错误。
    + 异常情形是指在 **当前环境** 下无法获得必要的信息来解决问题，因此只能结束当前运行路径，并抛给给上一级环境。
+ 抛异常过程：
    + 1. 系统会在堆上新建一个异常类对象；
    + 2. 结束当前执行路径；
    + 3. 从当前环境中返回异常对象引用；
    + 4. [异常处理机制]()接管程序，并向上寻找一个异常处理程序；
    + 5. 异常处理程序将程序从错误状态中恢复，从而是程序可以继续运行下去；
    + 6. 如果找不到异常处理程序，那么应该是退出当前程序，并输出错误异常。

+ Java中的异常机制允许我们：
    + 最坏状态：没有处理手段，则强制程序停止运行。
    + 理想状态：处理异常，并返回稳定状态。

+ 通过关键字 **throw** 抛出一个异常对象引用。
    ```java
    throw new Exception();
    throw new Exception("Exception info");
    ```

+ 异常参数如上面所示，在创建异常时，所有标准异常类都有两个构造器：
    + 默认无参构造方法。
    + 字符串构造方法，传入可以描述当前异常信息的字符串。 

####3. _捕获异常_
+ 监控区域/guarded region: 一段可能产生异常的代码，并且后面跟着处理这些异常的代码。
+ 语法：
    + try块，用于包围可能会抛出异常的方法块。
    + catch块，处理try块中抛出的异常. [异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理城区，然后进入catch字句执行，并且只有匹配的catch才会执行.]()
    + finally块，可选块，表明try块中无论是否发生异常，都会执行的逻辑操作。
    ```java
    try{
    // Code that might generate exceptions
    } catch{Type id1}
    // Handle exception of Type1
    } catch{Type2 id2}
    // Handle excetion of Type2
    } catch{Type2 id2}
    // Handle excetion of Type2
    } finally{
    // do something Whether or not error
    }
    // etc..
    ```

+ [终止与恢复:]() :heavy_exclamation_mark:
    + 终止模型：错误非常关键，一旦异常被抛出，就无法继续执行。[推荐使用.]()
    + 恢复模型：异常被处理后能继续执行程序。通过调用方法来修正错误，或者把try块放在while循环里，直到获得满意结果。[这种模型会导致耦合，增加代码编写和维护点额困难.]() ::

####4. _自定义异常_
+ Java虽然提供了一些列标准异常类，但是完全可以自己通过继承异常类实现自定义异常。(最好选择意义相近的类继承)
+ [对于一个异常类来说，最重要的是它的类名，名字应该尽量能够体现改异常的信息.]()
+ 所有异常类均实现了 **Throwable** 接口，从字面意义可看出实现该接口的类可以被抛出。
+ 所有异常类的根类是 **Exception** 类，该类默认实现了两种构造方法。
+ 打印异常信息时，[推荐使用System.err输出流，因为它不会像System.out输出流一样会有可能被重定向输出.]() e.printStackTrace()默认调用的是System.err输出流。
+ 示例：
    ```java
    class MyException extends Exception{
      public MyException(){}
      public MyException(String exceptionInfo){super(exceptionInfo);}  
    }
  
    public class TestException_1{
      public static void f() throws MyException{
        System.out.println("Throw");
      }
      public static void main(String[] args){
          try{
              f();
          }catch (MyException e){
              e.printStackTrace();
          }
      }
    }
    ```

####5. _异常说明_
+


####6. _捕获所有异常_


####7. _JAVA标准异常_


####8. [_使用finally进行清理_]()


####9. [_异常限制_]() :bangbang:


####10. _构造器_ 


####11. [_异常匹配_]()


####12. [_其他可选方式_]()
 
####13. [_异常使用指南_]() :bangbang:
应该在下列情况下使用异常：

+ 1. 在恰当的级别处理问题。(在知道该如何处理的情况下才捕获异常)
+ 2. 解决问题并且重新调用产生异常的方法。
+ 3. 进行少许修补，然后绕过异常发生的地方继续执行。
+ 4. 用别的数据进行计算，以代替方法预计会返回的值。
+ 5. 把当前运行环境下能做的事情尽量做完，然后把_相同_的异常重抛到更高层。
+ 6. 把当前运行环境下能做的事情尽量做完，然后吧_不同_的异常抛到更高层。
+ 7. 终止程序。
+ 8. 进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人）
+ 9. 让类库和程序更加安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资）




